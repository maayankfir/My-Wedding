import * as React from 'react';
import * as PropTypes from 'prop-types';
import { withValidateFieldEventEmitter } from './withValidateFieldEventEmitter';
import { withFieldWillValidateEventEmitter } from './withFieldWillValidateEventEmitter';
import { withFieldDidValidateEventEmitter } from './withFieldDidValidateEventEmitter';
import { withFieldDidResetEventEmitter } from './withFieldDidResetEventEmitter';
import { InputElement } from './InputElement';
import { FieldsStore } from './FieldsStore';
import flattenDeep from './flattenDeep';
import notUndefined from './notUndefined';
class FormWithConstraintsComponent extends React.Component {
}
export class FormWithConstraints extends withFieldDidResetEventEmitter(withFieldWillValidateEventEmitter(withFieldDidValidateEventEmitter(withValidateFieldEventEmitter(FormWithConstraintsComponent)))) {
    constructor() {
        super(...arguments);
        this.form = null;
        this.fieldsStore = new FieldsStore();
        this.fieldFeedbacksKeyCounter = 0;
    }
    getChildContext() {
        return {
            form: this
        };
    }
    computeFieldFeedbacksKey() {
        return `${this.fieldFeedbacksKeyCounter++}`;
    }
    validateFields(...inputsOrNames) {
        return this._validateFields(true, ...inputsOrNames);
    }
    validateForm() {
        return this.validateFieldsWithoutFeedback();
    }
    validateFieldsWithoutFeedback(...inputsOrNames) {
        return this._validateFields(false, ...inputsOrNames);
    }
    async _validateFields(forceValidateFields, ...inputsOrNames) {
        const fields = new Array();
        const inputs = this.normalizeInputs(...inputsOrNames);
        for (const input of inputs) {
            const field = await this.validateField(forceValidateFields, new InputElement(input));
            if (field !== undefined)
                fields.push(field);
        }
        return fields;
    }
    async validateField(forceValidateFields, input) {
        const fieldName = input.name;
        const field = this.fieldsStore.getField(fieldName);
        if (field === undefined) {
        }
        else if (forceValidateFields || !field.hasFeedbacks()) {
            field.clearValidations();
            this.emitFieldWillValidateEvent(fieldName);
            const arrayOfArrays = await this.emitValidateFieldEvent(input);
            console.assert(JSON.stringify(flattenDeep(arrayOfArrays).filter(notUndefined))
                ===
                    JSON.stringify(field.validations), `FieldsStore does not match emitValidateFieldEvent() result, did the user changed the input rapidly?`);
            this.emitFieldDidValidateEvent(field);
        }
        return field;
    }
    normalizeInputs(...inputsOrNames) {
        let inputs;
        if (inputsOrNames.length === 0) {
            inputs = [...this.form.querySelectorAll('[name]')];
            inputs = inputs.filter(input => input.validity !== undefined);
            inputs
                .filter(input => input.type !== 'checkbox' && input.type !== 'radio')
                .map(input => input.name)
                .forEach((name, index, self) => {
                if (self.indexOf(name) !== index) {
                    throw new Error(`Multiple elements matching '[name="${name}"]' inside the form`);
                }
            });
        }
        else {
            inputs = inputsOrNames.map(input => {
                if (typeof input === 'string') {
                    const query = `[name="${input}"]`;
                    const elements = [...this.form.querySelectorAll(query)];
                    if (elements.filter(el => el.validity === undefined).length > 0) {
                        throw new Error(`'${query}' should match an <input>, <select> or <textarea>`);
                    }
                    if (elements.filter(el => el.type !== 'checkbox' && el.type !== 'radio').length > 1) {
                        throw new Error(`Multiple elements matching '${query}' inside the form`);
                    }
                    const element = elements[0];
                    if (element === undefined) {
                        throw new Error(`Could not find field '${query}' inside the form`);
                    }
                    return element;
                }
                else {
                    return input;
                }
            });
        }
        return inputs;
    }
    isValid() {
        return this.fieldsStore.isValid();
    }
    hasFeedbacks() {
        return this.fieldsStore.hasFeedbacks();
    }
    reset() {
        return this.resetFields();
    }
    async resetFields(...inputsOrNames) {
        const fields = new Array();
        const inputs = this.normalizeInputs(...inputsOrNames);
        for (const input of inputs) {
            const field = await this.resetField(new InputElement(input));
            if (field !== undefined)
                fields.push(field);
        }
        return fields;
    }
    async resetField(input) {
        const fieldName = input.name;
        const field = this.fieldsStore.getField(fieldName);
        if (field === undefined) {
        }
        else {
            field.clearValidations();
            await this.emitFieldDidResetEvent(field);
        }
        return field;
    }
    render() {
        return React.createElement("form", Object.assign({ ref: form => this.form = form }, this.props));
    }
}
FormWithConstraints.childContextTypes = {
    form: PropTypes.instanceOf(FormWithConstraints).isRequired
};
