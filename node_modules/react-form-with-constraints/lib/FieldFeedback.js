var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
import * as React from 'react';
import * as PropTypes from 'prop-types';
import { FormWithConstraints } from './FormWithConstraints';
import { FieldFeedbacks } from './FieldFeedbacks';
import { Async } from './Async';
import { FieldFeedbackWhenValid } from './FieldFeedbackWhenValid';
import FieldFeedbackType from './FieldFeedbackType';
export class FieldFeedback extends React.Component {
    constructor(props, context) {
        super(props, context);
        this.validate = (input) => {
            const { when } = this.props;
            const { form, fieldFeedbacks } = this.context;
            const field = form.fieldsStore.getField(input.name);
            const validation = Object.assign({}, this.state.validation);
            if (fieldFeedbacks.props.stop === 'first' && field.hasFeedbacks(fieldFeedbacks.key) ||
                fieldFeedbacks.props.stop === 'first-error' && field.hasErrors(fieldFeedbacks.key) ||
                fieldFeedbacks.props.stop === 'first-warning' && field.hasWarnings(fieldFeedbacks.key) ||
                fieldFeedbacks.props.stop === 'first-info' && field.hasInfos(fieldFeedbacks.key)) {
                validation.show = undefined;
            }
            else {
                validation.show = false;
                if (typeof when === 'function') {
                    validation.show = when(input.value);
                }
                else if (typeof when === 'string') {
                    if (when === 'valid') {
                        validation.show = undefined;
                    }
                    else {
                        const validity = input.validity;
                        if (!validity.valid) {
                            if (when === '*') {
                                validation.show = true;
                            }
                            else if (validity.badInput && when === 'badInput' ||
                                validity.patternMismatch && when === 'patternMismatch' ||
                                validity.rangeOverflow && when === 'rangeOverflow' ||
                                validity.rangeUnderflow && when === 'rangeUnderflow' ||
                                validity.stepMismatch && when === 'stepMismatch' ||
                                validity.tooLong && when === 'tooLong' ||
                                validity.tooShort && when === 'tooShort' ||
                                validity.typeMismatch && when === 'typeMismatch' ||
                                validity.valueMissing && when === 'valueMissing') {
                                validation.show = true;
                            }
                        }
                    }
                }
                else {
                    throw new TypeError(`Invalid FieldFeedback 'when' type: ${typeof when}`);
                }
            }
            field.addOrReplaceValidation(validation);
            this.setState({
                validation,
                validationMessage: input.validationMessage
            });
            return validation;
        };
        this.fieldDidReset = (field) => {
            if (field.name === this.context.fieldFeedbacks.fieldName) {
                this.setState(prevState => ({
                    validation: Object.assign({}, prevState.validation, { show: undefined }),
                    validationMessage: ''
                }));
            }
        };
        this.key = context.fieldFeedbacks.addFieldFeedback();
        const { error, warning, info, when } = props;
        let type = FieldFeedbackType.Error;
        if (when === 'valid')
            type = FieldFeedbackType.WhenValid;
        else if (warning)
            type = FieldFeedbackType.Warning;
        else if (info)
            type = FieldFeedbackType.Info;
        if (type === FieldFeedbackType.WhenValid && (error || warning || info)) {
            throw new Error('Cannot have an attribute (error, warning...) with FieldFeedback when="valid"');
        }
        this.state = {
            validation: {
                key: this.key,
                type,
                show: undefined
            },
            validationMessage: ''
        };
    }
    componentWillMount() {
        const { form, fieldFeedbacks, async } = this.context;
        if (async)
            async.addValidateFieldEventListener(this.validate);
        else
            fieldFeedbacks.addValidateFieldEventListener(this.validate);
        form.addFieldDidResetEventListener(this.fieldDidReset);
    }
    componentWillUnmount() {
        const { form, fieldFeedbacks, async } = this.context;
        if (async)
            async.removeValidateFieldEventListener(this.validate);
        else
            fieldFeedbacks.removeValidateFieldEventListener(this.validate);
        form.removeFieldDidResetEventListener(this.fieldDidReset);
    }
    render() {
        const _a = this.props, { when, error, warning, info, className, classes, style, children } = _a, otherProps = __rest(_a, ["when", "error", "warning", "info", "className", "classes", "style", "children"]);
        const { validation, validationMessage } = this.state;
        const fieldFeedbackClassName = classes[validation.type];
        const classNames = className !== undefined ? `${className} ${fieldFeedbackClassName}` : fieldFeedbackClassName;
        if (validation.type === FieldFeedbackType.WhenValid) {
            return React.createElement(FieldFeedbackWhenValid, Object.assign({ "data-feedback": this.key, style: style, className: classNames }, otherProps), children);
        }
        if (validation.show) {
            const feedback = children !== undefined ? children : validationMessage;
            return React.createElement("span", Object.assign({ "data-feedback": this.key, className: classNames, style: Object.assign({ display: 'block' }, style) }, otherProps), feedback);
        }
        return null;
    }
}
FieldFeedback.defaultProps = {
    when: () => true,
    classes: {
        error: 'error',
        warning: 'warning',
        info: 'info',
        whenValid: 'when-valid'
    }
};
FieldFeedback.contextTypes = {
    form: PropTypes.instanceOf(FormWithConstraints).isRequired,
    fieldFeedbacks: PropTypes.instanceOf(FieldFeedbacks).isRequired,
    async: PropTypes.instanceOf(Async)
};
